import random
random.seed(21)
import numpy as np
from functools import partial
import bisect
import scipy.optimize as so


a = """ATGTCGGGGCGCGGCAAGGGCGGCAAGGGGCTCGGCAAGGGCGGCGCGAAGAGGCATCGC
AAGGTGCTCCGCGACAACATCCAGGGCATCACCAAGCCGGCGATCCGGAGGCTGGCGAGG
AGGGGCGGCGTGAAGCGCATCTCCGGGCTGATCTACGAGGAGACCCGCGGCGTGCTCAAG
ATCTTCCTCGAGAACGTCATCCGCGACGCCGTCACCTACACGGAGCACGCCCGCCGCAAG
ACCGTCACCGCCATGGACGTCGTCTACGCGCTCAAGCGCCAGGGCCGCACCCTCTACGGC
TTCGGCGGCTGA"""
b = """ATGTCAGGTCGTGGAAAAGGAGGCAAGGGGCTCGGTAAGGGAGGAGCGAAGCGTCATCGG
AAAGTTCTCCGTGATAACATTCAGGGAATCACTAAGCCGGCTATCCGGCGTCTTGCGAGA
AGAGGTGGAGTGAAGAGAATCAGCGGGTTGATCTACGAGGAGACCAGAGGCGTTTTGAAG
ATCTTCTTGGAGAACGTTATTCGCGATGCTGTGACGTACACTGAGCACGCCAGGCGGAAG
ACGGTGACCGCCATGGATGTTGTTTACGCCCTTAAGAGGCAGGGAAGGACTCTGTACGGG
TTCGGTGGTTAA"""

a = """ATGGCGGCGGCGGCGGCGGCGGCGGGGTACAGGGCGGAGGAGGAGTACGACTACCTGTTCAAGGTGGTGCTGATCGGGGACAGCGGCGTGGGGAAGTCGAACCTGCTGTCGCGGTTCGCGCGGGACGAGTTCAGCCTGGAGACCAGGTCCACCATCGGCGTCGAGTTCGCCACCAAGACCGTCCGCGTCGACGACAGGCTCGTCAAGGCCCAGATCTGGGACACCGCCGGCCAAGAGAGGTACCGCGCCATCACGAGCGCCTACTACCGCGGCGCGGTGGGCGCGCTGGTGGTGTACGACGTGACGCGCCGCATCACGTTCGAGAACGCGGAGCGGTGGCTCAAGGAGCTCCGCGACCACACGGACGCCAACATCGTCGTCATGCTCGTGGGCAACAAGGCCGACCTGCGCCACCTCCGCGCCGTCCCCGCGGAGGACGCCAGGGCGTTCGCCGAGGCGCACGGGACCTTCTCCATGGAGACGTCGGCGCTGGAGGCCACCAACGTGGAGGGCGCCTTCACCGAGGTGCTCGCGCAGATCTACCGCGTCGTCAGCCGGAACGCGCTCGACATCGGCGACGACCCCGCCGCGCCGCCCCGGGGGCGGACCATCGACGTCAGCGCCAAGGATGACGCCGTCACCCCCGTGAACAGCTCAGGGTGCTGCTCGTCTTGA"""
b = """---------------ATGGCGTCGGGGTACCGCGCGGAGGAGGAGTACGACTACCTGTTCAAGGTGGTGCTGATCGGGGACAGCGGCGTGGGCAAGTCGAACCTGCTGTCGCGGTTCGCCAGGGACGAGTTCAGCCTCGAGACCAGGTCCACCATCGGCGTCGAGTTCGCCACCAAGACCGTCCAGGTCGACGACAAGCTCGTCAAGGCGCAGATCTGGGACACCGCCGGGCAGGAGAGGTACCGCGCCATCACGAGCGCATACTACCGCGGCGCGGTGGGCGCGCTGGTGGTGTACGACGTGACCCGCCGCATCACCTTCGACAACGCCGAGCGCTGGCTGCGGGAGCTGCGGGACCACACGGACGCCAACATCGTGGTCATGCTGGTGGGCAACAAGGCCGACCTGCGCCACCTCCGCGCCGTGACGCCCGAGGACGCCGCGGCCTTCGCGGAGCGGCACGGCACCTTCTCCATGGAGACGTCGGCGCTGGACGCCACCAACGTCGACCGCGCCTTCGCCGAGGTGCTCCGCCAGATCTACCACGTCGTCAGCCGGAACGCGCTCGACATCGGGGAGGACCCCGCCGCGCCGCCCAGGGGAAAGACCATCGACGTCGGCGCCGCCAAGGACGAGGTCTCCCCCGTGAATACGGGCGGCTGCTGCTCGGCTTAG"""

def score_guess(ks_guess, seqab, D, slen):
    substitutions = int(ks_guess * slen + 0.5)
    pos = partial(random.randint, 0, slen - 1)
    repeats = 1000
    outer_reps = 10
    choice = random.choice

    diffs = []
    for rep in range(outer_reps):
        random.seed()
        ancestor = "".join(random.choice(seqab) for _ in range(slen))
        for rep in xrange(repeats):
            amut = bytearray(ancestor)
            bmut = bytearray(ancestor)

            for i in xrange(substitutions):
                mut = choice((amut, bmut))
                mut[pos()] = choice(seqab)

            diff = sum(aa != bb for aa, bb in zip(amut, bmut))
            diffs.append(diff)
           
    std = np.std(diffs)
    diffs.sort()

    idx0 = bisect.bisect_left(diffs, D - std)
    idx1 = bisect.bisect_right(diffs, D + std)
    n = (repeats * outer_reps) - abs(idx1 - idx0)
    print ks_guess, n
    return n

def mleks(_seqa, _seqb):

    # we only look at the 3rd basepair.
    seqa = _seqa[2::3].upper()
    seqb = _seqb[2::3].upper()

    seqa, seqb = zip(*((sab for sab in zip(seqa, seqb) if not "-" in sab)))
    seqa = "".join(seqa)
    seqb = "".join(seqb)
    

    D = sum(aa != bb for aa, bb in zip(seqa, seqb))

    seqab = seqa + seqb
    slen = len(seqab)/2

    scores = {}
    # give the optimizer the best guess from this range.
    kss = np.arange(0.25, 1.76, 0.25)
    for guess in kss:
        scores[guess] = score_guess(guess, seqab, D, slen)

    best_guess = sorted(scores.items(), key=lambda a: (a[1], a[0]))[0][0]
    r = so.fmin(score_guess, best_guess, args=(seqab, D, slen), disp=True, 
                xtol=0.2, maxfun=20)
    return r[0]


print mleks(a.replace("\n", ""), b.replace("\n", ""))
